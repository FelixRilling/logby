var logby=function(e){"use strict";const o={NONE:{val:-1},ERROR:{name:"ERROR",val:0},WARN:{name:"WARN",val:1},INFO:{name:"INFO",val:2},DEBUG:{name:"DEBUG",val:3},TRACE:{name:"TRACE",val:4}},t=(e,t,n)=>{let s=console.log;t===o.ERROR?s=console.error:t===o.WARN?s=console.warn:t===o.INFO&&(s=console.info),s(`${(new Date).toISOString()} ${t.name} ${e}`,...n)},n=(e,...o)=>o.some(o=>typeof e===o),s=e=>null==e,r=e=>(e=>!s(e)&&n(e,"object"))(e)||(e=>n(e,"function"))(e),l=e=>(e=>n(e,"string"))(e)?e:r(e)&&!s(e.name)?e.name:(e=>n(e,"symbol"))(e)&&!s(e.description)?e.description:null;class a{constructor(e,o){this.root=e,this.name=o}log(e,...o){this.root.level.val>=e.val&&this.root.appenders.forEach(t=>t(this.name,e,o))}error(...e){this.log(o.ERROR,...e)}warn(...e){this.log(o.WARN,...e)}info(...e){this.log(o.INFO,...e)}debug(...e){this.log(o.DEBUG,...e)}trace(...e){this.log(o.TRACE,...e)}}return e.Levels=o,e.Logby=class{constructor(){this.loggers=new Map,this.appenders=new Set([t]),this.level=o.INFO}getLogger(e){const o=l(e);if(null==o)throw new TypeError(`'${e}' is neither an INameable nor a string.`);if(!this.loggers.has(o)){const e=new a(this,o);this.loggers.set(o,e)}return this.loggers.get(o)}},e.defaultLoggingAppender=t,e}({});
//# sourceMappingURL=logby.min.js.map
