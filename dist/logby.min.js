var logby=function(n){"use strict";const o={NONE:{val:-1},ERROR:{name:"ERROR",val:0},WARN:{name:"WARN",val:1},INFO:{name:"INFO",val:2},DEBUG:{name:"DEBUG",val:3},TRACE:{name:"TRACE",val:4}},t=(n,o)=>typeof n===o,e=n=>null==n,i=n=>t(n,"string"),l=n=>!e(n)&&(t(n,"object")||t(n,"function")),s=(n,t,e)=>{const i=`${(new Date).toISOString()} ${n.name} ${t}`;let l=console.log;n===o.ERROR?l=console.error:n===o.WARN?l=console.warn:n===o.INFO&&(l=console.info);l(i,...e)};class a{constructor(n,o){this.root=n,this.name=o}log(n,...o){this.root.level.val>=n.val&&this.root.appenderQueue.forEach(t=>t(n,this.name,o))}error(...n){this.log(o.ERROR,...n)}warn(...n){this.log(o.WARN,...n)}info(...n){this.log(o.INFO,...n)}debug(...n){this.log(o.DEBUG,...n)}trace(...n){this.log(o.TRACE,...n)}}class r{constructor(n=o.INFO){this.loggerMap=new Map,this.level=n,this.appenderQueue=[s]}getLogger(n){let o;if(l(n)&&"name"in n)o=n.name;else{if(!i(n))throw new TypeError(`'${n}' is neither an INameable nor a string.`);o=n}if(this.loggerMap.has(o))return this.loggerMap.get(o);const t=new a(this,o);return this.loggerMap.set(o,t),t}}return n.Levels=o,n.Logby=r,n}({});
//# sourceMappingURL=logby.min.js.map
