var logby=function(n){"use strict";const t={NONE:{val:-1},ERROR:{val:0,name:"ERROR"},WARN:{val:1,name:"WARN"},INFO:{val:2,name:"INFO"},DEBUG:{val:3,name:"DEBUG"},TRACE:{val:4,name:"TRACE"}},o=n=>null==n,e=(n,t)=>typeof n===t,i=n=>e(n,"string"),a=n=>!o(n)&&(e(n,"object")||e(n,"function"));class l{constructor(n,t){this.root=n,this.name=t}log(n,t){this.root.level.val>=n.val&&this.root.appenderQueue.forEach(o=>o(n,this.name,t))}error(...n){this.log(t.ERROR,n)}warn(...n){this.log(t.WARN,n)}info(...n){this.log(t.INFO,n)}debug(...n){this.log(t.DEBUG,n)}trace(...n){this.log(t.TRACE,n)}}const s=(n,t,o)=>console.log(`${(new Date).toISOString()} ${n.name} ${t}`,...o);class u{constructor(n=t.INFO){this.loggerMap=new Map,this.level=n,this.appenderQueue=[s]}getLogger(n){let t;if(a(n)&&"name"in n)t=n.name;else{if(!i(n))throw new TypeError(`'${n}' is neither an INameable nor a string.`);t=n}if(this.loggerMap.has(t))return this.loggerMap.get(t);const o=new l(this,t);return this.loggerMap.set(t,o),o}}return n.Level=t,n.Logby=u,n}({});
//# sourceMappingURL=logby.min.js.map
